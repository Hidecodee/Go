package main

/*
 * [Example]:
 *     $ go build main.go 
 *     $ ./main md5 hash.txt dictionary.txt
 *     $ ./main sha256 hash.txt dictionary.txt
 *     $ ./main sha512 hash.txt dictionary.txt
 */

import (
    "os"
    "fmt"
    "bufio"
    "strings"
    "encoding/hex"
)

import (
    "crypto/md5"
    "crypto/sha256"
    "crypto/sha512"
)

func main () {
    if len(os.Args) < 4 { get_error("args < 4") }
    check_mode(os.Args[1])
    hack_password(os.Args[1], os.Args[2], os.Args[3])
}

func check_mode (mode string) {
    if mode != "sha256" && mode != "sha512" && mode != "md5" {
        get_error("crypto-hash function is not found")
    }
}

func hack_password (mode string, hash_file, dictionary string) {
    fhash, err := os.Open(hash_file)
    check_error(err)
    defer fhash.Close()

    var buff []byte = make([]byte, get_length(hash_file))
    _, err = fhash.Read(buff)
    check_error(err)

    var stat_hash = string(buff)
    stat_hash = strings.Replace(stat_hash, "\n", "", -1)

    file, err := os.Open(dictionary)
    check_error(err)
    defer file.Close()

    fmt.Println("----------------------------------")
    reader := bufio.NewReader(file)

    for {
        pasw, _ := reader.ReadString('\n')
        pasw = strings.Replace(pasw, "\n", "", -1)
        dynamic_hash := encrypt(mode, pasw)
        if stat_hash == dynamic_hash {
            fmt.Println("----------------------------------")
            fmt.Println("[SUCCESS]:", pasw)
            fmt.Println("----------------------------------")
            os.Exit(0)
        } else {
            fmt.Println("[FAILURE]:", pasw)
        }
    }
    
    fmt.Scanln()
}

func encrypt (crypt string, text string) string {
    if crypt == "md5" { 
        hash := md5.New() 
        hash.Write([]byte(text))
        return hex.EncodeToString(hash.Sum(nil))
    } else if crypt == "sha256" { 
        hash := sha256.New() 
        hash.Write([]byte(text))
        return hex.EncodeToString(hash.Sum(nil))
    } else { 
        hash := sha512.New() 
        hash.Write([]byte(text))
        return hex.EncodeToString(hash.Sum(nil))
    } 
}

func get_length (name string) int32 {
    stat, err := os.Stat(name)
    check_error(err)
    return int32(stat.Size())
}

func check_error (err error) {
    if err != nil { 
        fmt.Println("Error:", err)
        os.Exit(1) 
    }
}

func get_error (err string) {
    fmt.Println("Error:", err)
    os.Exit(1)
}
